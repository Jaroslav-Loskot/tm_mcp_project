import datetime
import os
import json
import re
import warnings
from jira import JIRA
from langgraph.prebuilt import ToolNode
from langchain.chat_models import init_chat_model
from dotenv import load_dotenv
from langchain_aws.chat_models.bedrock import ChatBedrock
from typing import Annotated, Dict, List
from langgraph.prebuilt import create_react_agent
from typing_extensions import TypedDict
from langchain_core.messages import convert_to_messages
from langgraph.graph import StateGraph, START, END
from langgraph.graph.message import add_messages
from langchain_core.tools import tool
from mcp_common.utils.bedrock_wrapper import call_nova_lite
import mcp_jira.helpers as helpers
from langchain_core.messages import HumanMessage, AIMessage, ToolMessage, SystemMessage
from langgraph_supervisor import create_supervisor
from langchain.chat_models import init_chat_model


warnings.filterwarnings(action="ignore", message=r"datetime.datetime.utcnow")


load_dotenv(override=True)
JIRA_URL = os.getenv("JIRA_BASE_URL")
JIRA_USER = os.getenv("JIRA_EMAIL")
JIRA_TOKEN = os.getenv("JIRA_API_TOKEN")

DEFAULT_CATEGORY = os.getenv("DEFAULT_PROJECT_CATEGORY", "")
EXCLUDED_KEYS = [k.strip() for k in os.getenv("EXCLUDED_PROJECT_KEYS", "").split(",") if k.strip()]

jira = JIRA(server=JIRA_URL, basic_auth=(JIRA_USER, JIRA_TOKEN))


def pretty_print_messages(update):
    # This function will now print the full history of messages
    # as they are updated, giving a clearer picture of the conversation.

    # Check for subgraph updates
    is_subgraph = False
    if isinstance(update, tuple):
        ns, update = update
        if len(ns) > 0:
            graph_id = ns[-1].split(":")[0]
            print(f"Update from subgraph {graph_id}:")
            is_subgraph = True
        else:
            print("Update from main supervisor graph:")

    # Iterate over the nodes in the update
    for node_name, node_update in update.items():
        if node_update is None or "messages" not in node_update:
            continue

        update_label = f"--- Messages from node '{node_name}' ---"
        if is_subgraph:
            update_label = f"\t{update_label}"
        
        print(update_label)

        # Convert the messages and print them one by one
        messages = convert_to_messages(node_update["messages"])
        for message in messages:
            indent = "\t\t" if is_subgraph else "\t"
            if isinstance(message, HumanMessage):
                print(f"{indent}Human: {message.content}")
            elif isinstance(message, AIMessage):
                # The AIMessage might contain tool calls or final output
                print(f"{indent}AI: {message.content}")
                if message.tool_calls:
                    print(f"{indent}AI is calling tools:")
                    for tool_call in message.tool_calls:
                        print(f"{indent}\tTool: {tool_call['name']}")
                        print(f"{indent}\tArgs: {json.dumps(tool_call['args'], indent=4)}")
            elif isinstance(message, ToolMessage):
                # This is the output of a tool call
                print(f"{indent}Tool Output from {message.name}: {message.content}")
            elif isinstance(message, SystemMessage):
                print(f"{indent}System: {message.content}")
        
        print("\n" + "="*80 + "\n") # Separator for clarity


def init_chat_model(model_key: str = "CLAUDE_MODEL_ID") -> ChatBedrock:
    model_id = os.environ[model_key]
    region = os.environ["AWS_REGION"]

    return ChatBedrock(
        model_id=model_id,
        region_name=region,
        model_kwargs={"temperature": 0}
    )



#### TOOLS ---------------------------------------------------------------------------------------------------------------

@tool
def list_issue_type_statuses_tool(project_key: str) -> List[Dict[str, List[str]]]:
    """
    Lists valid Jira statuses grouped by issue type for a given project.

    Returns:
      [
        { "type": "Bug", "available_statuses": ["To Do", "In Progress", "Done"] },
        { "type": "Story", "available_statuses": ["Backlog", "Selected", "Done"] },
        ...
      ]
    """
    try:
        issue_types = helpers.jira.issue_types_for_project(project_key)
        result = []
        for it in issue_types:
            statuses = getattr(it, "statuses", [])
            names = [s.name for s in statuses]
            result.append({"type": it.name, "available_statuses": names})
        return result
    except Exception as e:
        raise ValueError(f"Failed to retrieve issue-type statuses for project '{project_key}': {e}")





@tool
def parse_jira_date_tool(input_str: str) -> str:
    """
    Uses LLM to convert a natural language date expression into a Jira-compatible ISO date (YYYY-MM-DD).

    Example:
        input_str = "last month"
        → "2025-07-01"

    Returns:
        Date string like "2025-07-01"
    """
    today = datetime.date.today().isoformat()

    system_prompt = (
        f"You are a date conversion assistant for Jira JQL queries.\n"
        f"Today is: {today}\n\n"
        "Your task is to convert natural language time filters like 'last month', 'past 2 quarters', or "
        "'updated 3 weeks ago' into an absolute date in ISO format (YYYY-MM-DD).\n\n"
        "Guidelines:\n"
        "- Use 'updated >= <date>' if the input includes words like 'updated', 'changed', or 'modified'.\n"
        "- Otherwise, use 'created >= <date>'.\n"
        "- Convert durations as follows:\n"
        "   - weeks → 7 days per week\n"
        "   - months → 30 days per month\n"
        "   - quarters → 90 days per quarter\n"
        "   - years → 365 days per year\n"
        "- Only return a single date string in the format YYYY-MM-DD.\n"
        "- Do not explain your reasoning. Output only the computed date.\n"
    )

    user_prompt = f"Convert to date: {input_str}"

    response = call_nova_lite(system_prompt + "\n" + user_prompt)

    match = re.search(r"\d{4}-\d{2}-\d{2}", response)
    if match:
        return match.group(0)
    else:
        raise ValueError(f"Could not parse a valid date from response: {response}")



@tool
def resolve_project_name_tool(human_input: str) -> List[Dict[str, str]]:
    """
    Resolve a Jira project name from human-friendly input.
    Fetches available Jira projects and chooses the best match.

    Parameters:
    - human_input: Human-friendly name of the project (e.g., 'website revamp').

    Returns:
    - The matching Jira project name (e.g., 'Website Comapny'), or raises error if not found or invalid.
    """
    return helpers._resolve_project_name(human_input, os.environ["DEFAULT_PROJECT_CATEGORY"])



@tool
def check_jql(jql: str) -> Dict:
    """
    Executes a JQL query and returns an approximate count of matching Jira issues.

    Parameters:
    - jql: A valid Jira Query Language string (e.g., 'project = PROJ AND status = "To Do"')

    Returns:
    {
        "jql": "<your input>",
        "approximate_count": <integer>
    }

    Or in case of error:
    {
        "error": "...",
        "jql": "<your input>"
    }
    """
    try:
        count = jira.approximate_issue_count(jql_str=jql)
        return {"jql": jql, "approximate_count": count}
    except Exception as e:
        return {"error": str(e), "jql": jql}



tools = [parse_jira_date_tool, check_jql, list_issue_type_statuses_tool]





all_projects = helpers._list_projects()
project_map_str = "\n".join([f"{p['key']}: {p['name']}" for p in all_projects])

SYSTEM_PROMPT = f"""You are a Jira assistant that resolves human-friendly project names into exact Jira project keys.

    RULES:
    - A list of valid projects is provided below in the format '<KEY>: <NAME>'.
    - The user may refer to a project by either its name or an approximation of its name (e.g. "UniCredit Italy" or "UCB").
    - Your task is to find the best matching project key.
    - Only use keys from the provided list. Never make up a key.
    - If multiple projects match, return them all in ranked order.
    - Return only valid JSON like:
    ```json
    {{ "matches": ["ASUCIT"] }}
    ````
    - Once you finish your task pass the work back to your supervisor agent.

    Available Projects:
    {project_map_str}

    
    """
    
projects_agent = create_react_agent(
    model=init_chat_model("NOVA_LITE_MODEL_ID"),
    tools=[],
    prompt=(SYSTEM_PROMPT),
    name="projects_agent",
)


SYSTEM_PROMPT = """You are a helpful assistant that converts natural language into valid Jira JQL queries.

Core Rules:
- Always resolve project names from the user input *before* generating JQL or calling other tools.
- When a task requires resolution of project name or key, extract the core request from the user's last message.
- Hand off the task to the 'projects_agent' by generating a new message that contains only the essential information needed to perform the search.
- For example, if the user says "UniCredit Italy AND UniCredit Austria all opened issues...", your handoff message should be something like "resolve project names: 'UniCredit Italy', 'UniCredit Austria'".

- If project names were provided, only proceed to generate JQL after all names are resolved.

Tool Usage:
- Always use tools to resolve date expressions, and available issue types/statuses.
- Never ask the user to clarify; use tools to disambiguate.
- Once JQL is generated, call the check tool:
  - If it errors → fix and regenerate.
  - If 0 results → reconsider filters (e.g. status, date, type).
  - If valid with results → return the JQL and count.

JQL Construction Guidelines:
- Use issue types and statuses only after confirming their availability via tools.
- Only call the issue-type/status tool once per project unless the input changes.
- Use `resolution in (Unresolved, EMPTY)` for open/unresolved/incomplete.
- Use `resolution not in (Unresolved, EMPTY)` for closed/resolved/completed.
- If filtering by project, date, or priority alone → omit the resolution clause.
- If priority is specified → include it.
- For specific types or statuses:
  - Use `type IN (...)`, `status IN (...)`, or their `NOT IN` counterparts.
  - **Always enclose all list items in single quotes**:  
    ✅ `type IN ('Bug', 'Story')`  
    ❌ `type IN (Bug, Story)`

Date Handling:
- Use `updated >=` if the input mentions update/change/modification.
- Else use `created >=`.
- For durations:
  - `1 month` → `30d`, `1 quarter` → `90d`, `1 year` → `365d`.

Always substitute exact tool outputs in the final JQL (e.g., if a tool returns `"2025-07-02"`, use that date verbatim).

Return only JSON:
```json
{ "jql": "<generated JQL>", "approx_query_results": <number> }
```
"""    

supervisor = create_supervisor(
    model=init_chat_model("NOVA_LITE_MODEL_ID"),
    agents=[projects_agent],
    prompt=(SYSTEM_PROMPT),
    tools=tools,
    add_handoff_back_messages=False,
    output_mode="full_history",
).compile()


# The main execution loop
print("Starting the supervisor stream...")
print("="*80)

# We will now call pretty_print_messages without the last_message flag.
for chunk in supervisor.stream(
    {
        "messages": [
            {
                "role": "user",
                "content": "UniCredit Italy AND UniCredit Austria all opened issues with the type SLA Incident and Incident non SLA? Only for the last 3 months?",
            }
        ]
    },
):
    pretty_print_messages(chunk)

print("\n"+"="*80)
print("Stream finished.")
final_message_history = chunk["supervisor"]["messages"]